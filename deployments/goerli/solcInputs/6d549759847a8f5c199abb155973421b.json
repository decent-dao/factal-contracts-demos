{
  "language": "Solidity",
  "sources": {
    "contracts/ConnectFour/ConnectFour.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.17;\n\ncontract ConnectFour {\n    /// @notice revert if caller isn't current team\n    error NotYourTurn();\n    /// @notice revert if column choice is invalid\n    error InvalidSelection();\n    /// @notice revert if game has been completed\n    error GameOver();\n    /// @notice emiited when game is created\n\n    event GameCreated(uint gameId, address teamOne, address teamTwo);\n    /// @notice emitted after turn is successfully taken\n    event TurnTaken(uint indexed gameId, address team, uint8 column);\n    /// @notice emitted when game is complete\n    event GameFinished(uint gameId, address winner);\n\n    /// @notice holds game data\n    /// @param teamOne address of challenger\n    /// @param teamTwo address of challenged\n    /// @param winner address of winning team; default: address(0)\n    /// @param turn current turn is calculated using bitwise for basically odd/even teamOne/teamTwo\n    /// @param board holds game board data; each 'square' holds current data; 0 = no chip; 1 = team one; 2 = team two\n    struct Game {\n        address teamOne;\n        address teamTwo;\n        address winner;\n        uint8 turn;\n        uint8[7][6] board;\n    }\n\n    /// @notice Used as a counter for the next game index.\n    /// @dev Initialised at 1 because getGameIdFromAddress initializes mappings to 0.\n    uint public gameId = 1;\n\n    /// @notice An indexed list of games\n    /// @dev This automatically generates a getter for us, which will return `Game.player1`, `Game.player2`, `Game.moves`, and `Game.finished` (the arrays are skipped)\n    mapping(uint => Game) public getGame;\n\n    /// @notice An index of address to gameId\n    mapping(address => uint) public getGameIdFromAddress;\n\n    /// @notice prevent move if column is invalid\n    modifier validColumn(uint8 column) {\n        if (column > 6) revert InvalidSelection();\n        _;\n    }\n\n    /// @notice prevents gameplay if game is over\n    modifier gameOver(uint _gameId) {\n        if (getGame[_gameId].winner != address(0)) revert GameOver();\n        _;\n    }\n\n    /// @notice prevents teams being the same address\n    modifier uniqueTeams(address opponent) {\n        require(msg.sender != opponent);\n        _;\n    }\n\n    /**\n     * @notice challenge an address to a game of connect four\n     * @param opponent challened\n     * @dev opponent will go first\n     * @dev game id is increated each time a new game is created\n     * @dev season is over when timer (soon to be added) is past\n     */\n    function challenge(address opponent) external uniqueTeams(opponent) {\n        require(getGameIdFromAddress[msg.sender] == 0, \"Already playing.\");\n        require(getGameIdFromAddress[opponent] == 0, \"Opponent is already playing.\");\n\n        uint8[7][6] memory newBoard;\n        Game memory newGame = Game({\n            teamOne: msg.sender,\n            teamTwo: opponent,\n            turn: uint8(0),\n            winner: address(0),\n            board: newBoard\n        });\n        getGame[gameId] = newGame;\n        setGameIdFromAddress(newGame, gameId);\n\n        emit GameCreated(gameId, msg.sender, opponent);\n\n        gameId++;\n    }\n\n    /**\n     * Abandons the singleton game of msg.sender, if it exists.\n     * The game will still continue to be playable via makeMove,\n     * just not makeMove.\n     */\n    function abandonCurrentGame() external {\n        uint id = getGameIdFromAddress[msg.sender];\n        require(id != 0, \"Not currently playing.\");\n        setGameIdFromAddress(getGame[id], 0);\n    }\n\n    /**\n     * @notice current team plays a turn\n     * @param _gameId id of game\n     * @param columnIndex selected column for move, starting at 0\n     */\n    function makeMove(\n        uint8 _gameId,\n        uint8 columnIndex\n    ) public gameOver(_gameId) validColumn(columnIndex) {\n        Game storage game = getGame[_gameId];\n\n        /// @notice row where chip will land\n        uint8 row;\n        /// @notice assigned team number for squares\n        uint8 teamNum = game.turn & 1 == 0 ? 2 : 1;\n\n        /// @notice prevents plays being made by other addresses\n        /// @dev even or odd bitwise operator decides turn\n        /// @dev starts with team two\n        if (msg.sender != (game.turn & 1 == 0 ? game.teamTwo : game.teamOne)) {\n            revert NotYourTurn();\n        }\n\n        /// @notice finds where chip will land\n        for (uint8 i = 0; i < 7; i++) {\n            if (i > 5) {\n                revert InvalidSelection();\n            }\n            uint8 square = game.board[i][columnIndex];\n            if (square == 0) {\n                row = i++;\n                break;\n            }\n        }\n\n        /// @notice assigns chip to location onboard\n        game.board[row][columnIndex] = teamNum;\n        /// @notice increments turn\n        game.turn++;\n\n        emit TurnTaken(_gameId, msg.sender, columnIndex);\n\n        /// @notice checks surrounding squares for connected pieces\n        if (didPlayerWin(_gameId, columnIndex, row, teamNum)) {\n            game.winner = msg.sender;\n            setGameIdFromAddress(game, 0);\n            emit GameFinished(_gameId, msg.sender);\n        }\n    }\n\n    /**\n     * @notice caller plays a turn in their current game\n     * @param _columnNumber selected column for move, starting at 1\n     */\n    function move(uint _columnNumber) external {\n        uint id = getGameIdFromAddress[msg.sender];\n        require(id != 0, \"Not currently playing.\");\n        makeMove(uint8(id), uint8(_columnNumber - 1));\n    }\n\n    function setGameIdFromAddress(Game memory _game, uint _gameId) private {\n        getGameIdFromAddress[_game.teamOne] = _gameId;\n        getGameIdFromAddress[_game.teamTwo] = _gameId;\n    }\n\n    /// @notice checks square for team's chip\n    /// @param _gameId id of game\n    /// @param firstIndex column selected for new chip\n    /// @param secondIndex row where new chip lands\n    /// @param teamNum number assigned to team\n    function checkSquare(\n        uint8 _gameId,\n        uint8 firstIndex,\n        uint8 secondIndex,\n        uint8 teamNum\n    ) private view returns (bool) {\n        uint8[7][6] storage board = getGame[_gameId].board;\n        return board[firstIndex][secondIndex] == teamNum;\n    }\n\n    /// @notice checks the horizontal win\n    /// @param _gameId id of game\n    /// @param column column selected for new chip\n    /// @param row row where new chip lands\n    /// @param teamNum number assigned to team\n    function checkHorizontalWin(\n        uint8 _gameId,\n        uint8 column,\n        uint8 row,\n        uint8 teamNum\n    ) private view returns (uint) {\n        uint connectedPiecesCount = 1;\n\n        /// @dev checks to the right of new piece\n        for (uint8 i = column + 1; i < 7; i++) {\n            if (checkSquare(_gameId, row, i, teamNum)) {\n                connectedPiecesCount++;\n            } else {\n                break;\n            }\n        }\n        /// @dev checks to the left of new piece\n        if (column != 0) {\n            uint8 columnIndex = column - 1;\n            while (columnIndex >= 0) {\n                if (checkSquare(_gameId, row, columnIndex, teamNum)) {\n                    connectedPiecesCount++;\n                } else {\n                    break;\n                }\n                if (columnIndex == 0) {\n                    break;\n                } else {\n                    columnIndex--;\n                }\n            }\n        }\n\n        return connectedPiecesCount;\n    }\n\n    /// @notice checks the veritical win\n    /// @param _gameId id of game\n    /// @param column column selected for new chip\n    /// @param row row where new chip lands\n    /// @param teamNum number assigned to team\n    function checkVerticalWin(\n        uint8 _gameId,\n        uint8 column,\n        uint8 row,\n        uint8 teamNum\n    ) private view returns (uint) {\n        uint connectedPiecesCount = 1;\n\n        /// @dev checks rows above new piece\n        for (uint8 i = row + 1; i < 6; i++) {\n            if (checkSquare(_gameId, i, column, teamNum)) {\n                connectedPiecesCount++;\n            } else {\n                break;\n            }\n        }\n        /// @dev checks rows below new piece\n        if (row != 0) {\n            uint8 rowIndex = row - 1;\n            while (rowIndex >= 0) {\n                if (checkSquare(_gameId, rowIndex, column, teamNum)) {\n                    connectedPiecesCount++;\n                } else {\n                    break;\n                }\n                if (rowIndex == 0) {\n                    break;\n                } else {\n                    rowIndex--;\n                }\n            }\n        }\n        return connectedPiecesCount;\n    }\n\n    /// @notice checks the forward angle win\n    /// @param _gameId id of game\n    /// @param column column selected for new chip\n    /// @param row row where new chip lands\n    /// @param teamNum number assigned to team\n    function checkForwardAngleWin(\n        uint8 _gameId,\n        uint8 column,\n        uint8 row,\n        uint8 teamNum\n    ) private view returns (uint) {\n        uint connectedPiecesCount = 1;\n\n        /// @dev checks forward angle up\n        for (uint8 i = row + 1; i < 6 - row; i++) {\n            if (checkSquare(_gameId, i, i, teamNum)) {\n                connectedPiecesCount++;\n            } else {\n                break;\n            }\n        }\n\n        /// @dev checks forward angle down\n        if (row != 0 && column != 0) {\n            uint8 rowIndex = row - 1;\n            uint8 columnIndex = column - 1;\n            while (rowIndex >= 0 && columnIndex >= 0) {\n                if (checkSquare(_gameId, rowIndex, columnIndex, teamNum)) {\n                    connectedPiecesCount++;\n                } else {\n                    break;\n                }\n                if (rowIndex == 0 || columnIndex == 0) {\n                    break;\n                } else {\n                    rowIndex--;\n                    columnIndex--;\n                }\n            }\n        }\n        return connectedPiecesCount;\n    }\n\n    /// @notice checks the backward angle win\n    /// @param _gameId id of game\n    /// @param column column selected for new chip\n    /// @param row row where new chip lands\n    /// @param teamNum number assigned to team\n    function checkBackwardAngleWin(\n        uint8 _gameId,\n        uint8 column,\n        uint8 row,\n        uint8 teamNum\n    ) private view returns (uint) {\n        uint connectedPiecesCount = 1;\n\n        /// @dev checks backward angle down\n        if (row != 0) {\n            uint8 rowIndex = row - 1;\n            uint8 columnIndex = column + 1;\n            while (rowIndex >= 0 && columnIndex < 7) {\n                if (checkSquare(_gameId, rowIndex, columnIndex, teamNum)) {\n                    connectedPiecesCount++;\n                } else {\n                    break;\n                }\n                if (rowIndex == 0 || columnIndex >= 6) {\n                    break;\n                } else {\n                    rowIndex--;\n                    columnIndex++;\n                }\n            }\n        }\n\n        /// @dev checks forward angle down\n        if (column != 0) {\n            uint8 rowIndex = row + 1;\n            uint8 columnIndex = column - 1;\n            while (rowIndex < 6 && columnIndex >= 0) {\n                if (checkSquare(_gameId, rowIndex, columnIndex, teamNum)) {\n                    connectedPiecesCount++;\n                } else {\n                    break;\n                }\n                if (rowIndex >= 6 || columnIndex == 0) {\n                    break;\n                } else {\n                    rowIndex++;\n                    columnIndex--;\n                }\n            }\n        }\n        return connectedPiecesCount;\n    }\n\n    /// @notice checks to see if current play won the game\n    /// @param _gameId id of game\n    /// @param column column selected for new chip\n    /// @param row row where new chip lands\n    /// @param teamNum number assigned to team\n    function didPlayerWin(\n        uint8 _gameId,\n        uint8 column,\n        uint8 row,\n        uint8 teamNum\n    ) private view returns (bool) {\n        /// @dev using new chip location as middle == m\n        /// @dev [ [ C+1 | R-1 ] [  C+1  ] [ C+1 | R+1 ] ]\n        /// @dev [ [    R-1    ] [ C | R ] [    R+1    ]\n        /// @dev [ [ C-1 | R-1 ] [  C-1  ] [ C-1 | R+1 ] ]\n\n        uint horionalCount = checkHorizontalWin(_gameId, column, row, teamNum);\n        if (horionalCount == 4) {\n            return true;\n        }\n        uint vericalCount = checkVerticalWin(_gameId, column, row, teamNum);\n        if (vericalCount == 4) {\n            return true;\n        }\n        uint forwardAngleCount = checkForwardAngleWin(\n            _gameId,\n            column,\n            row,\n            teamNum\n        );\n        if (forwardAngleCount == 4) {\n            return true;\n        }\n        uint backwardAngleCount = checkBackwardAngleWin(\n            _gameId,\n            column,\n            row,\n            teamNum\n        );\n        if (backwardAngleCount == 4) {\n            return true;\n        }\n        return false;\n    }\n\n    function getGameBoard(\n        uint8 _gameId\n    ) public view returns (uint8[7][6] memory) {\n        return getGame[_gameId].board;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}